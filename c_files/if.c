/*

入力変数
	型
	値の区間
	検証対象の処理内で変更されうるかどうか
	網の細かさ（mesh size）

*/

int if_func(int a)
{
	// 分岐の評価式の内容を読み取り、それに一致する区間部分のみ処理を行う
	// else 式が有る場合、入力の区間から if の評価式の区間を省いた範囲で動かす実行pathが増える
	
	// 木の枝が別れるので後で実行するpath用に変数状態の記録を行う
	// スナップショットを完全に作成すると無駄が大きそうなので、後処理で変更されるものだけ保存する？
	
	if (a < 10) {
		a += 10;
	}else {
		a -= 10;
	}
}

int for_func(int a)
{
	// ループは愚直に逐次実行
	for (int i=0; i<10; ++i) {
		
		// 分岐の判定条件で使用している変数がループ内で変更される可能性が有る場合、
		// 判定条件によっては実行pathを増やす
		if (a < 10) {
			a += 10;
		}else {
			a -= 10;
		}
		
	}
	
	// 区間を持つ変数が繰り返しの条件に関わっていた場合は？
	// a = [3, 10]
	// 範囲を網羅するように実行して、利用する変数の区間を求める
	int b = 0
	for (int i=0; i<a; ++i) {
		b += 10
	}
	
	// もし for の condition が 上記の i < a のような場合は、a が 3 〜 10 の範囲のそれぞれで
	// ループ処理をやり直す必要は生じない。大きい区間の 10 までを実行すれば良い。
	// しかしループの処理内で、a 変数の値を使っている場合はそうもいかない。a 変数に依存しているので。
	
}


// 区間を持つ変数が複数有った場合
// 変数の持つ区間は１つとは限らず、複数のケースもある
// 変数セットのバリエーションも用意出来るようにする
int multi_var_func(int a, int b)
{
	
	if (a + b < a * b) {
		return a / b;
	}else {
		return a - b;
	}
	
	/*
	
	a = [0, 3]
	b = [0, 3]
	
	*/
	
	if (a + b < a * b) {
		
		// 掛け算の方が大きい、結果が負の数にならない場合は、変数に 0 は無い

		// そもそも色々な方程式の解を手慰みなコードで確定出来るわけは無い
		// きちんと演算式を読みとり、それにあった解法を適用してあげるのがベスト
		// http://akita-nct.jp/yamamoto/lecture/2005/5E/nonlinear_equation/text/html/node7.html
		
		return a / b;
	}else {
		return a - b;
	}
	
	
}

